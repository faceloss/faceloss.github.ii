<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NIO学习</title>
      <link href="/2019/08/09/nio-xue-xi/"/>
      <url>/2019/08/09/nio-xue-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="1、NIO的学习"><a href="#1、NIO的学习" class="headerlink" title="1、NIO的学习"></a>1、NIO的学习</h3><p>重点：Buffer缓冲区、Channel读写通道、Selectors选择器监听通道</p><p>jdk1.4引入的io api，new io或者叫none blockint io（可代替原来io），nio以更高效方式读写io</p><h5 id="1、JAVA-NIO-和-IO的主要区别"><a href="#1、JAVA-NIO-和-IO的主要区别" class="headerlink" title="1、JAVA NIO 和 IO的主要区别"></a>1、JAVA NIO 和 IO的主要区别</h5><ul><li><p>传统id是面向流、阻塞io（字节数据流动）</p></li><li><p>nio是面向缓冲区、非阻塞io、选择器（通道和缓冲区，字节放缓冲区）</p></li><li><p>阻塞非阻塞以及selectors是针对网络io（channel负责传输、buffer负责存储）</p></li></ul><h5 id="2、缓冲区buffer的数据存取"><a href="#2、缓冲区buffer的数据存取" class="headerlink" title="2、缓冲区buffer的数据存取"></a>2、缓冲区buffer的数据存取</h5><ul><li>buffer在nio中负责数据的存取。缓冲区就是数组用于存储不同数据类型的数据<ul><li><strong>根据数据类型不同boolean除外，提供相应的缓冲区</strong></li><li>ByteBuffer、CharBuffer、ShortBuffer、Int、Long、Float、DoubleBuffer</li><li>上述缓冲区管理方式都是通过allocate()获取缓冲区，ByteBuffer最常用</li><li>Buffer中的核心方法就是put和get，实现comparble继承Buf</li><li>缓冲区中还有四个核心属性：campacity最大容量声明不可变、limit可操作数据大小(后面无法读写)、position(缓冲区正在操作的位置)，mark：记录当前postition的位置（可以通过reset回复到mark位置）</li><li><strong>flip()方法</strong>从写切换到读数据模式，将limit指针指到之前写的postion位置，然后position指向0（开始进行读数据）</li><li>get()方法从0到limit读，读完position==limit，然后使用rewind()把position放到0，可以重复读buf数据</li><li>clear()清空缓冲区回到最初状态（缓冲区中数据还在，只是处于被遗忘状态，指针回归了）</li><li>记住：<code>0&lt;= mark &lt;= position &lt;= limit &lt;= capacity</code></li></ul></li></ul><h5 id="3、直接缓冲区和非直接缓冲区"><a href="#3、直接缓冲区和非直接缓冲区" class="headerlink" title="3、直接缓冲区和非直接缓冲区"></a>3、直接缓冲区和非直接缓冲区</h5><ul><li>非直接缓冲区：通过allocate()将缓冲区建立在jvm的内存中</li><li>直接缓冲区：通过allocateDirect()分配直接缓冲区，建立在物理内存中（操作系统内容中），可以提高效率</li><li>Read: 物理磁盘read–&gt;os内核地址空间copy到–&gt;jvm用户地址空间read到–&gt;用户程序中</li><li>Write：用户程序write–&gt;jvm内存copy–&gt;os内核地址空间write–&gt;物理磁盘</li><li>程序通过非直接缓冲区读写过程中存在 copy的过程，比较浪费时间</li><li>直接缓冲区：物理内存中开辟映射文件（内存页）：用户地址空间–内核地址空间，提高效率、资源浪费、不安全。（System.gc也不可控回收这块内存，长时间需要使用这块内存的场景比较适合）</li></ul><h5 id="4、通道channel的原理与获取"><a href="#4、通道channel的原理与获取" class="headerlink" title="4、通道channel的原理与获取"></a>4、通道channel的原理与获取</h5><ul><li>CPU把权限给DMA，IO操作就通过DMA去操作了，如果读写量大，就会建立大量DMA总线—&gt;更新成channel</li><li>Channel是一个独立的处理器，附属于cpu（大型应用程序channel效率会高，不用dma）</li><li>通道：用于源节点和目标节点的连接。在nio中负责缓冲区数据的传输，channel不存储数据，因此需要配合缓冲区传输</li><li>通道的主要实现类： java.nio.channels.channel:file、socket、serverSocket、datagram-Channel分别对应文件、tcp、udp的io通道</li><li>获取通道：<ul><li>Java提供getChannel的方法<ul><li>本地io：FileInputStream/output、RandomAccessFile</li><li>网络io：Socket、ServerSocket、DatagramSocket</li></ul></li><li>jdk1.7以后的NIO2针对通道提供静态方法open()</li><li>NIO的files工具类 newBtyeChannel()</li></ul></li></ul><h5 id="5、通道的数据传输与内存映射文件"><a href="#5、通道的数据传输与内存映射文件" class="headerlink" title="5、通道的数据传输与内存映射文件"></a>5、通道的数据传输与内存映射文件</h5><ul><li><p>通道要配合缓冲区使用，channel、buffer</p></li><li><p>步骤如下：通道连接着目标和源节点</p><ul><li>获取通道： getchannel、opne、newByteChannel方法</li><li>分配指定的缓冲区： ByteBuffer.allocate 非直接缓冲区、直接缓冲区</li><li>将通道中数据存入缓冲区： inchannel.read(buf) != -1 in通道写到buf</li><li>将缓冲区中的数据写入通道： buf.flip()切换到读模式，out通道中去读buf中的数据 buf.clear清空缓存区</li><li>上面总结一句话<strong>从in通道读数据到buf，再把buf数据写到out通道</strong><code>读写是针对当前程序、或者说buffer</code></li></ul></li><li><p>直接缓冲区的文件复制</p><ul><li>通过Buffer.allocateDirect或者channel.map() 获得</li></ul></li></ul><pre class="line-numbers language-java"><code class="language-java">    Buffer buf <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//非直接缓冲区</span>  FileChannel inChannel <span class="token operator">=</span> FileChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span>openOption<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//直接缓冲区</span>    MappedByteBuffer inmap <span class="token operator">=</span> inChannel<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>MapMode<span class="token punctuation">.</span>READ_ONLY<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> inChannel<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    MappedByteBuffer inmap <span class="token operator">=</span> outChannel<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>MapMode<span class="token punctuation">.</span>WRITE_ONLY<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> inChannel<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//直接缓冲区通过通道map获得、或者allocateDirect 前者的读写直接读写缓冲区，不操作通道</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dst <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>inmap<span class="token punctuation">.</span>limit<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//limit可用空间</span>    inmap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//从映射文件中中读到dst中</span>    outmap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//写到outmap中物理内存映射文件 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6、分散读取和聚集写入"><a href="#6、分散读取和聚集写入" class="headerlink" title="6、分散读取和聚集写入"></a>6、分散读取和聚集写入</h5><ul><li>分散读取：将通道中的数据分散到多个缓冲区中去</li><li>聚集写入：将多个缓冲区的数据聚集到通道中</li></ul><h5 id="7、NIO字符集"><a href="#7、NIO字符集" class="headerlink" title="7、NIO字符集"></a>7、NIO字符集</h5><ul><li>Charset 编码：字符串到字节数组 解码：字节数组到字符串</li><li>Charset.availableCharsets 获得一个map记录 string-&gt;charset 的个数</li></ul><h5 id="8、阻塞与非阻塞"><a href="#8、阻塞与非阻塞" class="headerlink" title="8、阻塞与非阻塞"></a>8、阻塞与非阻塞</h5><ul><li><p>client 到 server</p><ul><li>阻塞：客户端发送读写请求给服务端，服务端判断不确定，线程会处于堵塞状态，如何解决某一个线程阻塞的问题？ 多线程为客户端发送过来的请求分配一个线程（线程池，尽可能利用cpu资源），多线程解决io阻塞问题（但是cpu没有100%的利用）</li><li>非阻塞：核心概念选择器selectors，<ul><li>通道会注册到选择器上（选择器监控通道状况，如果请求事件完全准备就绪，才会分配到服务端的一个或多个线程上去执行），降低了阻塞率</li></ul></li></ul></li><li><p>阻塞IO</p><ul><li>传输后无法确认客户端是否发送完全，需要socketChannel.shutdown</li></ul></li><li><p>非阻塞IO</p><p>1、通道负责连接传输、缓冲区负责数据存取、选择器负责SelectableChannel的多路复用器，用于监控SelectableChannel的io状况</p><p>2、fileChannel不能切换成非阻塞模式</p><p>3、非阻塞IO流程如下：</p><p>客户端：</p><ul><li>获取通道</li><li>切换非阻塞模式：channel.configureBlocking(false);</li><li>分配指定大小缓冲区</li><li>发送数据到服务端 buf.put buf.flip channel.write(buf) <strong>buf的put是写buf,flip切换成buf读模式 读取buf把buf的内容write到通道channel中</strong></li></ul><p>服务端：（利用selector监听通道状态）</p><ul><li>获取通道</li><li>切换非阻塞模式</li><li>通道绑定端口</li><li>获取选择器 Selector.open()</li><li>通道注册到选择器上，通道有个register方法 channel.register(selector, options),options是int类型作用是检测通道的什么状态：通道与选择器之间的关系<strong>服务端channel注册通道接受事件</strong><ul><li>读状态 read 1</li><li>写状态 write 4 </li><li>连接状态 connection 8</li><li>接收状态 accept 16</li><li>多个事件时候使用 与运算符</li></ul></li><li>轮询的获取选择器上已经准备就绪事件while(selector.select &gt; 0)</li><li>如果有就绪事件，就获取选择器中的所有事件的迭代器，然后一个一个的判断状态做对应动作<strong>读、写、就收、连接</strong></li><li>判断是接受就绪，就获取客户端连接并切换成非阻塞模式（获得的客户端连接，读写时候都要切换）</li><li>客户端的连接通道也要注册到selector，监控读就绪状态</li><li>获取读就绪状态就绪通道，如果准备就绪且通道有值就读chanel写到buf中，flip一下就可以读buf里的值了</li></ul></li></ul><h5 id="9、DataGramChannel"><a href="#9、DataGramChannel" class="headerlink" title="9、DataGramChannel"></a>9、DataGramChannel</h5><ul><li>send是写通道、receive是读通道 、bufput是写、get是读  channel.send(buf)针对通道是写针对buf是读，这样理解不会乱</li></ul><h5 id="10、管道"><a href="#10、管道" class="headerlink" title="10、管道"></a>10、管道</h5><p>JavaNIO管道是两个线程之间的单向数据连接，pipe有一个source和sink通道。数据会被写入sink通道，从source通道读区</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏中心社区业务</title>
      <link href="/2019/06/19/you-xi-zhong-xin-she-qu-ye-wu/"/>
      <url>/2019/06/19/you-xi-zhong-xin-she-qu-ye-wu/</url>
      
        <content type="html"><![CDATA[<h2 id="小米游戏社区"><a href="#小米游戏社区" class="headerlink" title="小米游戏社区"></a>小米游戏社区</h2><h3 id="社区业务背景"><a href="#社区业务背景" class="headerlink" title="社区业务背景"></a>社区业务背景</h3><h5 id="社区服务项"><a href="#社区服务项" class="headerlink" title="社区服务项"></a>社区服务项</h5><blockquote><p><strong>客户端：骑士团和游戏中心，web端：游戏中心web站，如下图所示</strong></p></blockquote><h6 id="骑士团："><a href="#骑士团：" class="headerlink" title="骑士团："></a>骑士团：</h6><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://ww1.sinaimg.cn/large/007Kpj57gy1ga6s7d1gmrj31d30kc4qp.jpg" alt="image"></p><h6 id="游戏中心："><a href="#游戏中心：" class="headerlink" title="游戏中心："></a>游戏中心：</h6><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://ww1.sinaimg.cn/large/007Kpj57gy1ga6s6v14nuj31cw0kcb29.jpg" alt="image"></p><h6 id="web站"><a href="#web站" class="headerlink" title="web站:"></a>web站:</h6><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://ww1.sinaimg.cn/large/007Kpj57gy1ga6rvq3t4zj31fv0ezh17.jpg" alt="image"></p><blockquote><p>上面三个2C项目都使用了社区服务端业务，游戏中心复用了骑士团的社区服务，其中相应的如winehouse、honor等模块没有使用，如下图所示是服务模块用例图</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://ww1.sinaimg.cn/large/007Kpj57gy1ga6s96lv6oj30dh0bx74w.jpg" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://ww1.sinaimg.cn/large/007Kpj57gy1ga6safcf7nj319g145q5v.jpg" alt="image"></p><h5 id="社区相关模块"><a href="#社区相关模块" class="headerlink" title="社区相关模块"></a>社区相关模块</h5><p>1、对于上面的模块分类，搜索推荐模块获取的信息来自于搜索推荐组那边（李立松），用户关系由中台那边负责（宫伟俊），社区内容功能以及数据的统计则是属于社区组这边负责。</p><p>2、对于管理系统分为MIS管理台和MIS审核后台（这两个后台系统辅助运营来做社区业务的运营工作），MIS审核后台是使用的vue+iview+springboot+jada搭建的前后台工程，MIS管理后台是jsp+js+rose+blink+spring+jada+es，审核后台主要负责对社区的内容安全负责，MIS管理后台负责对社区的用户、内容控制，功能项更多。除此之外，在CMS上还有UGC管理内容和账户，以及配置型来配置内容的发布(CMS不由社区组这边负责)</p><p>3、此外上面服务的数据持久化都使用到了Mistore、MySQL来存储游戏社区服务的数据</p><table>    <tbody><tr>        <td>模块</td>         <td>服务</td>        <td>说明</td>        <td>开发语言</td>    </tr>    <tr>        <td rowspan="7">社区</td>            <td><font color="red">migame-viewpoint</font></td>        <td>帖子</td>         <td>java</td>     </tr>    <tr>        <td><font color="red">migame-counter-ser</font></td>        <td>计数服务</td>         <td>java</td>     </tr>    <tr>        <td><font color="red">knights-tag</font></td>        <td>标签</td>         <td>java</td>     </tr>    <tr>        <td><font color="red">knights-reply</font></td>        <td>回复</td>         <td>java</td>     </tr>    <tr>        <td>migame-like</td>        <td>社区点赞服务</td>         <td>go</td>     </tr>    <tr>        <td><font color="red">knights-topic</font></td>        <td>话题</td>         <td>java</td>     </tr>    <tr>        <td><font color="red">knights-viewpoint-task</font></td>        <td>topic热度值</td>         <td>java</td>     </tr>    <tr>        <td rowspan="1">推荐</td>            <td> <font color="red">migame-viewpoint</font></td>        <td>游戏中心ugc推荐</td>         <td>java</td>     </tr>    <tr>        <td rowspan="2">feeds</td>            <td> migame-feeds</td>        <td>游戏中心feeds</td>         <td>go</td>     </tr>    <tr>        <td>knights-follow-relationship</td>        <td>关注分发服务</td>         <td>go</td>     </tr>    <tr>        <td rowspan="4">游戏数据相关</td>            <td><font color="red"> knights-game-transfer</font></td>        <td>游戏信息中转服务</td>         <td>java</td>     </tr>    <tr>        <td>score</td>        <td>游戏评分服务</td>         <td>c/c++</td>     </tr>    <tr>        <td>knights-subscribe</td>        <td>订阅</td>         <td>java</td>     </tr>    <tr>        <td><font color="red">knights-game-stat</font></td>        <td>用户游戏统计数据</td>         <td>java</td>     </tr>    <tr>        <td rowspan="3">用户/关系</td>            <td> user</td>        <td>用户系统</td>         <td>c/c++</td>     </tr>    <tr>        <td> relation</td>        <td>关系系统</td>         <td>c/c++</td>     </tr>    <tr>        <td> migame-verified</td>        <td>实名认证</td>         <td>java</td>     </tr>    <tr>        <td rowspan="5">管理系统</td>            <td> <font color="red">knights-mis</font></td>        <td>用户/社区后台管理系统</td>         <td>java</td>     </tr>    <tr>        <td><font color="red">knights-mis-task</font> </td>        <td>mis定时任务，用于数据接收</td>         <td>java</td>     </tr>    <tr>        <td><font color="red">knights-mis-common</font> </td>        <td>mis通用组件</td>         <td>java</td>     </tr>        <tr>        <td> <font color="red">migame-review-platform</font></td>        <td>审核后台服务端</td>         <td>java</td>     </tr>    <tr>        <td><font color="red">migame-review-web</font> </td>        <td>审核后台前端</td>         <td>vue</td>     </tr>    <tr>        <td rowspan="1">搜索</td>            <td>knights-searches</td>        <td>搜索</td>         <td>java</td>     </tr>    <tr>        <td rowspan="2">消息服务</td>            <td>msg</td>        <td>milink消息/push消息</td>        <td>c/c++</td>     </tr>        <tr>        <td>knights-message-pool</td>        <td>消息池服务</td>        <td>java</td>     </tr></tbody></table><h5 id="服务简单描述"><a href="#服务简单描述" class="headerlink" title="服务简单描述"></a>服务简单描述</h5><p><strong>Vp</strong>：游戏、漫画下的评论，图文、合集视频都属于帖子服务</p><p><strong>Reply</strong>：回复就是对帖子以及回复进行回复</p><p><strong>Game-stat</strong>：玩过的游戏、游戏时长排行榜、已安装游戏等游戏相关状态服务 </p><p><strong>Game-transfer</strong>：获取游戏信息、开发者信息、漫画信息等服务 </p><p><strong>Honor</strong>：荣耀勋章属于骑士团服务项，在游戏中心中没使用，为用户新增角色，佩戴勋章圣杯等个性化服务 </p><p><strong>Topic</strong>：视频类型的帖子设置标签功能（例如游戏日常、精彩时刻、魔性小游戏、游戏漫谈、主机游戏、吃鸡时刻、。。。。） </p><p><strong>Tag</strong>： 给viewpoint设置标签，来区别帖子 </p><p><strong>Vp-task</strong>：消费信息实时计算热度以及其他的定时任务</p><p><strong>Winhouse</strong>：骑士团酒馆服务，游戏中心中未使用，即酒馆活动，参与用户发布视频参与活动 </p><p><strong>Counter-ser</strong>：计数服务，类似帖子浏览数、回复数等</p><p><strong>Recommend</strong>：通过rpc调用catlog为huyu-recommend的推荐信息展示圈子的发现页 </p><p><strong>Feeds</strong>：获取世界圈子，骑士团首页</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h3 id="社区技术栈"><a href="#社区技术栈" class="headerlink" title="社区技术栈"></a>社区技术栈</h3><h5 id="中台组件"><a href="#中台组件" class="headerlink" title="中台组件"></a>中台组件</h5><ol><li>milink：tcp接入层</li><li>mistore：kv存储</li><li>iris(mifllow)：消息队列</li><li>L5(mlb)：服务调度系统</li><li>blink：rpc框架</li><li>rose：mvc框架</li><li>protobuf：消息传输格式<h5 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h5></li></ol><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://ww1.sinaimg.cn/large/007Kpj57gy1ga6sou9z77j311i0itjrq.jpg" alt="image"></p><h5 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h5><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://ww1.sinaimg.cn/large/007Kpj57gy1ga6sp3t6ebj311i0itgnk.jpg" alt="image"></p><h5 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h5><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://ww1.sinaimg.cn/large/007Kpj57gy1ga6spi62psj311i0it76b.jpg" alt="image"></p><h3 id="技术栈介绍"><a href="#技术栈介绍" class="headerlink" title="技术栈介绍"></a>技术栈介绍</h3><h5 id="Nginx和Milink"><a href="#Nginx和Milink" class="headerlink" title="Nginx和Milink"></a>Nginx和Milink</h5><p><strong>Nginx:</strong> </p><p>1、C语言开发，一个高性能Http和反向代理服务器</p><p>2、结合nodejs使用，作为web站的负载均衡工具</p><p>3、nginx的优势是处理静态请求，cpu内存使用率低，apache适合处理动态请求，所以现在一般前端用nginx作为反向代理抗住压力，apache作为后端处理动态请求。</p><p><strong>milink:</strong></p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://ww1.sinaimg.cn/large/007Kpj57gy1ga6sd45ou6j30r20h23zl.jpg" alt="image" style="zoom:67%;"><p>配置方式：<br>三段式命令字 L5 ID、CMD ID、监控ID，命令字是三段式的：业务-方法名，需要在ZK上配置milink转发</p><p>使用目的：<br>1、app到server端的服务可用 2、服务端push到客户端的成功率和及时性 3、方便业务快速接入</p><p>使用逻辑：在手机侧有milink的sdk，后台有milinkSVR–&gt;业务SVR</p><p>milinkSDK提供稳定长连接（保证连接成功率、心跳保活机制、重连策略、容错策略）</p><h5 id="Mlb-L5"><a href="#Mlb-L5" class="headerlink" title="Mlb(L5)"></a>Mlb(L5)</h5><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://ww1.sinaimg.cn/large/007Kpj57gy1ga6sdhtmswj311o0j8q3v.jpg" alt="image" style="zoom:67%;"><p>用处：配合blink使用，在RPC调用时，提供路由管理、负载均衡、过载保护，过载报警等<br>特点：高性能，高可靠，业务解耦</p><p>路由：Xbox集成，平滑上下线，存在一定的配置延迟，modid +cmdid抽象成一个服务，配合Xbox平台做业务的上下线</p><p>负载：普通轮询、加权轮询(基于响应时间、基于平均响应时间)</p><p>过载保护：感知服务过载、恢复–&gt;（熔断与恢复）</p><h5 id="Blink和Rose"><a href="#Blink和Rose" class="headerlink" title="Blink和Rose"></a>Blink和Rose</h5><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://ww1.sinaimg.cn/large/007Kpj57gy1ga6sdokaqkj30qw0ccmy8.jpg" alt="image"></p><p>介绍：Blink工作在TCP协议之上，是在Netty基础上构建的RPC通信框架，使用TCP传输、使用proto做序列化，因此速度快</p><p>对于<strong>RPC</strong>架构：client、server、clientstub、serverstub</p><p>client服务调用方</p><p>server服务提供者</p><p>clientstub存放服务端的地址消息将客户端请求参数打包成网络消息，通过网络远程发送到服务方</p><p>serverstub接受客户端发送的信息，消息解包后调用本地方法</p><p>除去RPC的调用方式，社区也使用了<strong>Rose</strong>的rest（http）接口来提供配置以及测试数据等使用功能</p><p>Rose是HTTP的web解决方案，基于Spring基础上构建的Web开发框架，它符合Servlet规范，且大量的采用约定优于配置的策略，比如Controller、DAO默认名称</p><h5 id="Miflow"><a href="#Miflow" class="headerlink" title="Miflow"></a>Miflow</h5><blockquote><p>下图是miflow的总体架构</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://ww1.sinaimg.cn/large/007Kpj57gy1ga6sdwfoy9j30ud0gsgpi.jpg" alt="image"></p><p>介绍：分布式队列服务，miflow提供C++、Golang、Java三种方式发送消息，且兼容Iris旧协议<br>，iris是自研的异步消息队列，模型是生产者-消费者模型（使用：生产者需要申请TopicId,给topicId配置指定的writer地址，业务中调用iris接口将消息发送到agent,消费者s2s服务，需要注册L5，并把L5 ID与TopicId绑定）</p><p>原因：为何使用消息队列呢？消息队列去除服务间耦合，限流保护服务器稳定，异步处理降低接口延迟， （一个通信纽带，纽带可以直接实时通信，也可以缓存做异步通信）</p><h5 id="Mistore"><a href="#Mistore" class="headerlink" title="Mistore"></a>Mistore</h5><blockquote><p>下图是mistore的总体架构</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://ww1.sinaimg.cn/large/007Kpj57gy1ga6se4ic5ij30p50fxjti.jpg" alt="image"></p><p>介绍：分布式的NOSQL存储，SSD的MYSQL集群和MEMORY的REDIS集群服务、接入层ACC的QPS~6万/秒<br>、Manager管理节点主备故障自动切换、TRSF迁移平滑的扩容/缩容</p><p>模式：mysql+redis模式1和纯redis模式</p><p>模式1读写分离，写入mysql再binlog同步到redis,读从redid读，同步延迟约10ms</p><p>模式2读写都使用redis缓存</p><p>对于两种模式的选择参考原则：(1)、模式1仅支持kv存储模式2还额外支持hset、zset (2)、模式1可以先持久化再同步缓存的机制，数据一致性更强，模式二在升级和故障时数据丢失较多 (3)、具体业务的特点</p><p>使用：适合记录数据量小且高频访问的场景（配置：申请appid、l5id、模调id，在zookeeper对应路径定义catlog索引及配置相应参数,然后在业务即可以获取对应mistore Client来操作kv数据）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 小米工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> migame </tag>
            
            <tag> archi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>game-arch</title>
      <link href="/2019/06/09/game-arch/"/>
      <url>/2019/06/09/game-arch/</url>
      
        <content type="html"><![CDATA[<p>确切的说是米聊服务器端使用的技术栈，大致有下面这些：</p><ul><li>Rose（MVC框架）</li><li>Blink（RPC框架）</li><li>Milink（客户端访问框架，小米链路层服务）</li><li>MLB（负载均衡）</li><li>nginx（反向代理+负载均衡）</li><li>zookeeper（云配置管理）</li><li>Iris（消息队列MQ）</li><li>ProtocolBuffer（数据传输格式）</li><li>Log4j（日志系统）</li><li>Mistore（后端存储 redis+mysql）</li><li>mysql（关系型数据库）</li><li>HugeGraph（图数据库）</li><li>模调Module Call（S2S调用监控系统）</li><li>StatWatcher（C2S调用监控告警系统）</li></ul><p>米聊架构图：</p><p>一、Rose</p><p>Rose框架是从人人网引入的一个开源的高效的Java Web开发框架，基于SpringMVC，提供SpringMVC的基本功能，并在此上面简化了部分功能，降低了使用门槛。</p><p>总体来说对外提供Server服务（包括TCP，HTTP等接口），对内访问DB，支持小米技术栈的各种框架集成。帮助开发者将更多时间聚焦于业务逻辑实现而非底层的开发，快速迭代项目。</p><p>二、Blink</p><p>Blink是一个分布式，高性能和透明化的rpc（remote process call）框架，主要特点：</p><ul><li>基于netty</li><li>私有的传输协议，支持命令字模式</li><li>可以方便的整合模调系统，监控运行状态</li><li>支持L5动态负载均衡模式，无缝对接L5</li><li>直接对接一切基于SPP或MCP框架的C++服务</li><li>直接对接milink服务，bitmap服务和mistore存储</li></ul><p>通过Blink框架就可以对外提供RPC接口，包括对Server端的S2S接口和对客户端的C2S接口。</p><p>三、Milink</p><p>Milink其实是小米自己做的一个链路层服务，主要解决三个问题：</p><ul><li>保证app到server链路的可用性</li><li>解决服务器push到客户端的成功率和及时性</li><li>方便业务快速接入</li></ul><p>Milink的整体架构：</p><p>Milink的部署架构：</p><p>四、MLB负载均衡</p><p>MLB是一个稳定可靠高效的负载均衡服务，MLB拆开来就是Module+L5+Business，即业务模块间通过L5进行调用。</p><p>Server端暴露一个服务的时候需要配置L5，将modid+cmdid与ip:port对应起来，调用方通过制定modid和cmdid来确定ip:port，从而知道应该调到哪台机器哪个端口。配置示例如下：</p><p>MLB具备以下几个功能：</p><ul><li>可以快速的进行手动上线、下线，灰度发布，流量切换</li><li>可以做更加精确的接口部署，对于流量大的接口单独部署</li></ul><p>参考：<a href="https://wiki.n.miui.com/pages/viewpage.action?pageId=131023121" target="_blank" rel="noopener">https://wiki.n.miui.com/pages/viewpage.action?pageId=131023121</a></p><p>四、nginx（反向代理+负载均衡）</p><p>前端页面（管理后台）的负载均衡使用nginx实现，server提供http服务和页面，部署好服务后，提供给运维一组ip:port和域名的映射关系，就可以使用域名访问http服务了。业界开源的框架，没什么好说的。</p><p>五、zookeeper（云配置管理）</p><p>zk在整个项目架构中充当了一个云配置管理的角色，主要有2个作用：</p><ul><li>业务中用到的一些配置变量可以再zk上管理，当需要更改配置的时候，不需要重启服务器；</li><li>与其他组件连接的一些配置，比如mysql，mistore，mlb等</li></ul><p>六、Iris（消息队列MQ）</p><p>Iris是一个简单的MQ中间件，其原理就是生产者将数据打给Iris，Iris通过L5和RPC调用Blink的s2s服务（push过程）。和大部分的MQ一样，生产者生产数据，消费者消费数据。</p><p>七、ProtocolBuffer（数据传输格式）</p><p>Protocol Buffers是google发明的一种数据交换格式，独立于语言，独立于平台。与其他的数据交换格式有所不同，Protocol Buffers是一种二进制的格式，因此在网络传输的时候效率更高，相对于json它的文件体积更小，相对于xml，它的解析速度更快。</p><p>示例：</p><pre><code>package com.wangjun.pb;message AddressBook {  repeated Person people = 1;}message Person {  required string name = 1;  required int32 id = 2;  optional string email = 3;  repeated PhoneNumber phones = 4;} message PhoneNumber {    required string number = 1; }</code></pre><p>八、Log4j（日志系统）</p><p>log4j应该都比较熟悉了，一个很好的日志框架，方便查看日志，排查问题。</p><p>九、Mistore（后端存储 redis+mysql）</p><p>mistore是一种快速高效的存储，底层基于redis和mysql，通过KV和Milist存储，使用集群的方式。</p><p>一个业务使用mistore存储数据的话首先要申请，存储类型由mysql和redis自由组合，如果选择两种的话，mysql会作为持久化存储。申请完毕后会生成appid和L5Modid，其调用也是通过MLB做负载均衡的，其中，增删查改分别对应不同且固定的cmdid，有了L5Modid和cmdid就可以找到ip:port进行存储的读写。</p><p>十、mysql（关系型数据库）</p><p>有些业务需要关系型数据库的支持，比如用户发布的广播列表的索引，可以先通过查mysql查询所有广播id，再去mistore查询广播的详情，综合mysql和mistore使业务更加稳定健壮。</p><p>十一、HugeGraph（图数据库）</p><p>HugeGraph是百度在2018年中旬开源的一款图数据库（Graph Database）系统，可以存储海量的顶点（Vertex）和边（Edge）。实现了Apache ThinkerPop 3框架，支持Gremlin图查询语言。HugeGraph支持多用户并行操作，用户可输入Gremlin查询语句，并及时得到图查询结果。也可以再用户程序中调用hugeGraph API进行图分析或查询。</p><p>米聊的用户关系数据就存储在了hugeGraph中，方便查询二度好友等关系。</p><p>十二、模调Module Call（S2S调用监控系统）</p><p>模调监控就是模块调用监控，是一个对模块间调用数据进行采集、计算、展示并报警的系统平台。可以检测并不只包含：</p><ul><li>模块间调用的成功率</li><li>模块间调用的响应时间</li><li>模块间调用的失败原因详细分类</li><li>模块间的调用链，定位系统瓶颈</li></ul><p>模调监控系统的原理</p><ul><li>每次RPC调用之后手动将结果上报给模调监控数据库。</li><li>模调监控系统定期扫描该数据库来实现监控RPC调用的情况。</li></ul><p>手动上报举例：</p><pre><code>try {            GetAccountInfoRsp response = GetAccountInfoRsp.parseFrom(blinkResponse.getBody());            if (response.getRetCode() == 0) {                // 上报模调监控数据--成功                ModuleCallUtil.successCall(invokeId, providerId,interfaceId, providerIp, delay);                return response;           } else {                // 上报模调监控数据--失败                ModuleCallUtil.failCall(invokeId, providerId, interfaceId, providerIp, retval, delay);                throw new MiliaoAuditException(RetCode.ERROR_BLINK);           }       } catch (InvalidProtocolBufferException e) {       // 上报模调监控数据--失败           ModuleCallUtil.failCall(invokeId, providerId, interfaceId, providerIp, retval, delay);            throw new MiliaoAuditException(RetCode.ERROR_PARSE_PB);       }</code></pre><p>使用模调的时候，自己的业务需要申请的一个业务模调id，还必须知道对方的s2s服务的模调id和模调接口id这三个参数，以便模调系统知道此次s2s调用，从哪个业务发起调用到哪个业务的哪个服务。</p><p>十三、StatWatcher（C2S调用监控告警系统）</p><p>如果说模调系统是监控s2s服务的，那么StatWatcher就是检测c2s服务的。严格来讲StatWatcher是属于Milink框架的，这里单独拿出来和模调类比更容易理解。</p><p>与模调一样，服务端代码中也需要显式的上报c2s服务调用结果，通过begin方法监控指定的命令字，通过end方法上报服务的返回code。</p><pre><code>@Cmd(id = 1, name = "miliao.relation.maybeknow")public ServiceResponse getMayBeKnow(RpcInvocationBean inv, byte[] bytes) {    StatWatcher watcher = new StatWatcher();    watcher.begin("miliao.relation.maybeknow");    try {       ...   } catch (Exception e) {       ...   }    watcher.end(retCode);   ...    return inv.getResponse();}</code></pre><p>模块本地log目录（一般存储在/home/work/log/{$businessName}/）每分钟统计一次本模块的运行调用stat.log，该stat.log被用于监控报警，监控系统会定期的读取stat.log的内容，生成服务调用报告和告警。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 小米工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> migame </tag>
            
            <tag> archi </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
