<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>game-arch</title>
      <link href="/2020/09/09/game-arch/"/>
      <url>/2020/09/09/game-arch/</url>
      
        <content type="html"><![CDATA[<p>确切的说是米聊服务器端使用的技术栈，大致有下面这些：</p><ul><li>Rose（MVC框架）</li><li>Blink（RPC框架）</li><li>Milink（客户端访问框架，小米链路层服务）</li><li>MLB（负载均衡）</li><li>nginx（反向代理+负载均衡）</li><li>zookeeper（云配置管理）</li><li>Iris（消息队列MQ）</li><li>ProtocolBuffer（数据传输格式）</li><li>Log4j（日志系统）</li><li>Mistore（后端存储 redis+mysql）</li><li>mysql（关系型数据库）</li><li>HugeGraph（图数据库）</li><li>模调Module Call（S2S调用监控系统）</li><li>StatWatcher（C2S调用监控告警系统）</li></ul><p>米聊架构图：</p><p>一、Rose</p><p>Rose框架是从人人网引入的一个开源的高效的Java Web开发框架，基于SpringMVC，提供SpringMVC的基本功能，并在此上面简化了部分功能，降低了使用门槛。</p><p>总体来说对外提供Server服务（包括TCP，HTTP等接口），对内访问DB，支持小米技术栈的各种框架集成。帮助开发者将更多时间聚焦于业务逻辑实现而非底层的开发，快速迭代项目。</p><p>二、Blink</p><p>Blink是一个分布式，高性能和透明化的rpc（remote process call）框架，主要特点：</p><ul><li>基于netty</li><li>私有的传输协议，支持命令字模式</li><li>可以方便的整合模调系统，监控运行状态</li><li>支持L5动态负载均衡模式，无缝对接L5</li><li>直接对接一切基于SPP或MCP框架的C++服务</li><li>直接对接milink服务，bitmap服务和mistore存储</li></ul><p>通过Blink框架就可以对外提供RPC接口，包括对Server端的S2S接口和对客户端的C2S接口。</p><p>三、Milink</p><p>Milink其实是小米自己做的一个链路层服务，主要解决三个问题：</p><ul><li>保证app到server链路的可用性</li><li>解决服务器push到客户端的成功率和及时性</li><li>方便业务快速接入</li></ul><p>Milink的整体架构：</p><p>Milink的部署架构：</p><p>四、MLB负载均衡</p><p>MLB是一个稳定可靠高效的负载均衡服务，MLB拆开来就是Module+L5+Business，即业务模块间通过L5进行调用。</p><p>Server端暴露一个服务的时候需要配置L5，将modid+cmdid与ip:port对应起来，调用方通过制定modid和cmdid来确定ip:port，从而知道应该调到哪台机器哪个端口。配置示例如下：</p><p>MLB具备以下几个功能：</p><ul><li>可以快速的进行手动上线、下线，灰度发布，流量切换</li><li>可以做更加精确的接口部署，对于流量大的接口单独部署</li></ul><p>参考：<a href="https://wiki.n.miui.com/pages/viewpage.action?pageId=131023121" target="_blank" rel="noopener">https://wiki.n.miui.com/pages/viewpage.action?pageId=131023121</a></p><p>四、nginx（反向代理+负载均衡）</p><p>前端页面（管理后台）的负载均衡使用nginx实现，server提供http服务和页面，部署好服务后，提供给运维一组ip:port和域名的映射关系，就可以使用域名访问http服务了。业界开源的框架，没什么好说的。</p><p>五、zookeeper（云配置管理）</p><p>zk在整个项目架构中充当了一个云配置管理的角色，主要有2个作用：</p><ul><li>业务中用到的一些配置变量可以再zk上管理，当需要更改配置的时候，不需要重启服务器；</li><li>与其他组件连接的一些配置，比如mysql，mistore，mlb等</li></ul><p>六、Iris（消息队列MQ）</p><p>Iris是一个简单的MQ中间件，其原理就是生产者将数据打给Iris，Iris通过L5和RPC调用Blink的s2s服务（push过程）。和大部分的MQ一样，生产者生产数据，消费者消费数据。</p><p>七、ProtocolBuffer（数据传输格式）</p><p>Protocol Buffers是google发明的一种数据交换格式，独立于语言，独立于平台。与其他的数据交换格式有所不同，Protocol Buffers是一种二进制的格式，因此在网络传输的时候效率更高，相对于json它的文件体积更小，相对于xml，它的解析速度更快。</p><p>示例：</p><pre><code>package com.wangjun.pb;message AddressBook {  repeated Person people = 1;}message Person {  required string name = 1;  required int32 id = 2;  optional string email = 3;  repeated PhoneNumber phones = 4;} message PhoneNumber {    required string number = 1; }</code></pre><p>八、Log4j（日志系统）</p><p>log4j应该都比较熟悉了，一个很好的日志框架，方便查看日志，排查问题。</p><p>九、Mistore（后端存储 redis+mysql）</p><p>mistore是一种快速高效的存储，底层基于redis和mysql，通过KV和Milist存储，使用集群的方式。</p><p>一个业务使用mistore存储数据的话首先要申请，存储类型由mysql和redis自由组合，如果选择两种的话，mysql会作为持久化存储。申请完毕后会生成appid和L5Modid，其调用也是通过MLB做负载均衡的，其中，增删查改分别对应不同且固定的cmdid，有了L5Modid和cmdid就可以找到ip:port进行存储的读写。</p><p>十、mysql（关系型数据库）</p><p>有些业务需要关系型数据库的支持，比如用户发布的广播列表的索引，可以先通过查mysql查询所有广播id，再去mistore查询广播的详情，综合mysql和mistore使业务更加稳定健壮。</p><p>十一、HugeGraph（图数据库）</p><p>HugeGraph是百度在2018年中旬开源的一款图数据库（Graph Database）系统，可以存储海量的顶点（Vertex）和边（Edge）。实现了Apache ThinkerPop 3框架，支持Gremlin图查询语言。HugeGraph支持多用户并行操作，用户可输入Gremlin查询语句，并及时得到图查询结果。也可以再用户程序中调用hugeGraph API进行图分析或查询。</p><p>米聊的用户关系数据就存储在了hugeGraph中，方便查询二度好友等关系。</p><p>十二、模调Module Call（S2S调用监控系统）</p><p>模调监控就是模块调用监控，是一个对模块间调用数据进行采集、计算、展示并报警的系统平台。可以检测并不只包含：</p><ul><li>模块间调用的成功率</li><li>模块间调用的响应时间</li><li>模块间调用的失败原因详细分类</li><li>模块间的调用链，定位系统瓶颈</li></ul><p>模调监控系统的原理</p><ul><li>每次RPC调用之后手动将结果上报给模调监控数据库。</li><li>模调监控系统定期扫描该数据库来实现监控RPC调用的情况。</li></ul><p>手动上报举例：</p><pre><code>try {            GetAccountInfoRsp response = GetAccountInfoRsp.parseFrom(blinkResponse.getBody());            if (response.getRetCode() == 0) {                // 上报模调监控数据--成功                ModuleCallUtil.successCall(invokeId, providerId,interfaceId, providerIp, delay);                return response;           } else {                // 上报模调监控数据--失败                ModuleCallUtil.failCall(invokeId, providerId, interfaceId, providerIp, retval, delay);                throw new MiliaoAuditException(RetCode.ERROR_BLINK);           }       } catch (InvalidProtocolBufferException e) {       // 上报模调监控数据--失败           ModuleCallUtil.failCall(invokeId, providerId, interfaceId, providerIp, retval, delay);            throw new MiliaoAuditException(RetCode.ERROR_PARSE_PB);       }</code></pre><p>使用模调的时候，自己的业务需要申请的一个业务模调id，还必须知道对方的s2s服务的模调id和模调接口id这三个参数，以便模调系统知道此次s2s调用，从哪个业务发起调用到哪个业务的哪个服务。</p><p>十三、StatWatcher（C2S调用监控告警系统）</p><p>如果说模调系统是监控s2s服务的，那么StatWatcher就是检测c2s服务的。严格来讲StatWatcher是属于Milink框架的，这里单独拿出来和模调类比更容易理解。</p><p>与模调一样，服务端代码中也需要显式的上报c2s服务调用结果，通过begin方法监控指定的命令字，通过end方法上报服务的返回code。</p><pre><code>@Cmd(id = 1, name = "miliao.relation.maybeknow")public ServiceResponse getMayBeKnow(RpcInvocationBean inv, byte[] bytes) {    StatWatcher watcher = new StatWatcher();    watcher.begin("miliao.relation.maybeknow");    try {       ...   } catch (Exception e) {       ...   }    watcher.end(retCode);   ...    return inv.getResponse();}</code></pre><p>模块本地log目录（一般存储在/home/work/log/{$businessName}/）每分钟统计一次本模块的运行调用stat.log，该stat.log被用于监控报警，监控系统会定期的读取stat.log的内容，生成服务调用报告和告警。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
